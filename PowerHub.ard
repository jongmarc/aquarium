/* 

  General information ESP8226
  ---------------------------
  - use 3.3 dedicated power supply for the ESP8226
  - pull the RESET + CH_PID lines high, but not the GPIO lines (with 1K - 10K ohm resistors)
  - use 115,200bps baud rate
  - set AT+CWMODE=1 to ensure ESP8226 act as a station (not an AP)
  - set AT+JAP="ssid_goes_here","password_here"
  - check AT+CIFSR to see if there is an IP-adress assigned
  - set AT+CIPMUX=1 to ensure multiple connections
  - set AT+CIPSERVER=1,4043 to open a port on 4043 for listening

  General port bit shifting
  -------------------------
  - switch  port with ports = ports ^  (int)pow(2,<PORT in range 1 - 16> - 1);
  - enable  port with ports = ports |  (int)pow(2,<PORT in range 1 - 16> - 1); 
  - disable port with ports = ports & ~(int)pow(2,<PORT in range 1 - 16> - 1);
*/

#include <SPI.h>
#include <SD.h>
#include <EEPROM.h>
#include <Wire.h>
#include "RTClib.h"

#define DEBUG                   false
#define BAUD_RATE_ARDUINO       115200
#define BAUD_RATE_ESP8226       115200
#define EEPROM_ADDRESS_PORTMAP  0

const String SSID = "Sitecom186990";
const String PASS = "DHZ4FBQLBJKX";
RTC_DS1307 rtc;


const int pinChipSelectSDCard = 4;
boolean ports[] = { 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1 }; // default port setting
String incomingData;

void setup() {
  Serial.begin( BAUD_RATE_ARDUINO );
  Serial1.begin( BAUD_RATE_ESP8226 );
  delay(1000);
  
  Wire.begin();
  rtc.begin();
  if (! rtc.isrunning()) {
    Serial.println("00-00-00 00:00:00 ERROR: RTC is NOT running!");
  } else {
    // rtc.adjust(DateTime(2015, 5, 7, 20, 38, 10)); // uncomment to adjust the current date / time
  }

  initializeCardReader();

  log( "Initialize port map from EEPROM" );
//  EEPROM.put( EEPROM_ADDRESS_PORTMAP, ports); // use only to reset the port modes
  EEPROM.get( EEPROM_ADDRESS_PORTMAP, ports);

  initializeESP8226();  
  
  incomingData = "";
  
  log( "Initialization complete, waiting for external commands" );
}

void loop() {
  
  DateTime now = rtc.now();
  if ( now.second() < 30 )
    enablePort(1);
  else
    disablePort(1);
  

  while ( Serial1.available() > 0 ) {
    char received = Serial1.read();
    incomingData += received;

    if ( received == '\n' ) {
      processInstruction( incomingData );
      incomingData = "";
    }
    
    if ( incomingData.length() > 256 ) {
      incomingData = "";
    }
  }
}  

void processInstruction( String instruction ) {
  if ( instruction.indexOf( "+IPD," ) > -1 ) {
    String channel = instruction.substring( instruction.indexOf( "+IPD," ) + 5, instruction.indexOf( ",", instruction.indexOf( "+IPD," ) + 5 ) );
    String data = instruction.substring( instruction.indexOf( ":" ) + 1);
    String command = data;
    String value = data;
    if ( data.substring( 0, 3 ) == "GET" ) {
      // handle http request
      if ( command.indexOf( "?" ) > 0 ) {
        command = command.substring( command.indexOf( "?" ) + 1 );
        command = command.substring( 0, command.indexOf( "=" ) );
      }
      if ( value.indexOf( "?" ) > 0 ) {
        value = value.substring( value.indexOf( "=" ) + 1 );
        value = value.substring( 0, value.indexOf( " " ) );
      }
    } else {
      // handle tcp request
      command = command.substring( 0, command.indexOf( "=" ) );
      value = value.substring( value.indexOf( "=" ) + 1, value.length() - 1 );
    }

    String response = "";
    command.toUpperCase();
    if ( value.toInt() > 0 && value.toInt() <= sizeof( ports ) ) {
      if ( command == "ENABLE" ) {
        enablePort( value.toInt() );
        response = "ON";
      } else if ( command == "DISABLE" ) {
        disablePort( value.toInt() );
        response = "OFF";
      } else if ( command == "SWITCH" ) {
        if ( getPortStatus( value.toInt() ) == 0 ) {
          enablePort( value.toInt() );
          response = "ON";
        } else { 
          disablePort( value.toInt() );
          response = "OFF";
        }
      } else if ( command == "STATUS" ) {
          if ( getPortStatus( value.toInt() ) == 0 ) {
            response = "OFF";
          } else {
            response = "ON"; 
          }
      } else {
        response = "Unknown command \"" + command + "\" from input \"" + data + "\"";
        error( response );
      }
      EEPROM.put( EEPROM_ADDRESS_PORTMAP, ports);
    } else if ( command == "STATUS" ) {
        // show overall status
        for ( int portIndex = 0; portIndex < sizeof( ports ); portIndex++ ) {
          response += ports[portIndex];
        }
    } else {
      response = "Unknown port \"" + value + "\" from input \"" + data + "\"";
      error( response );
    }

    sendSerialData( channel, "HTTP/1.1 200 OK\r\nContent-Type: text/plain; charset=utf-8\r\nContent-Length: " + String( response.length() ) + "\r\n\r\n" + response + "\r\n" );        
  } 
}


 void sendSerialData(String channel, String text) {
   text = text + "\r\n";
   String message = "AT+CIPSEND=" + channel + "," + text.length() + "\r\n";
   
   sendData( message, 1000, false );   
   sendData( text, 1000, false );
}

String sendData(String command, const int timeout, boolean debug)
{
    String response = "";
    
    Serial1.print( command ); // send the read character to the esp8266

    
    long int time = millis();
    
    while( ( time + timeout ) > millis()) {
      while( Serial1.available() ) {
        // The esp has data so display its output to the serial window 
        char c = Serial1.read(); // read the next character.
        response += c;
      }  
    }

    if ( DEBUG ) {
      Serial.println(response);
    }
    command.trim();
    log( "Sending to WIFI: " + command );
    
    return response;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// Send and receive data by wireless connections
//
////////////////////////////////////////////////////////////////////////////////////////////////////


void initializeESP8226() {  
  sendData( "AT+RST\r\n", 2000, DEBUG ); // reset module
  sendData( "AT+CWMODE=1\r\n", 1000, DEBUG ); // configure as a station
  sendData( "AT+CWJAP=\"" + SSID + "\",\"" + PASS + "\"\r\n", 4000, DEBUG ); // connect to network
  sendData( "AT+CIFSR\r\n", 1000, DEBUG ); // get ip address
  sendData( "AT+CIPMUX=1\r\n", 1000, DEBUG ); // configure for multiple connections
  sendData( "AT+CIPSERVER=1,4043\r\n", 1000, DEBUG ); // turn on server on port 80
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// Port handling
//
////////////////////////////////////////////////////////////////////////////////////////////////////

void enablePort( int portNumber ) {
  if ( ports[portNumber - 1] != 1 ) {
    ports[portNumber - 1] = 1;
    EEPROM.put( EEPROM_ADDRESS_PORTMAP, ports );
    log( "Port " + String( portNumber ) + " turned on" );
  }
}

void disablePort( int portNumber ) {
  if ( ports[portNumber - 1] != 0 ) {
    ports[portNumber - 1] = 0;
    EEPROM.put( EEPROM_ADDRESS_PORTMAP, ports );
    log( "Port " + String( portNumber ) + " turned off" );
  }
}

boolean getPortStatus( int portNumber ) {
  return ports[ portNumber - 1 ];
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// Storing and retrieving persistant information
//
////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeCardReader() {
  Serial.println( getTimestamp() + " INFO : Initializing SD card" );

  if ( !SD.begin( pinChipSelectSDCard ) ) {
    Serial.println("ERROR: Card failed, or not present");
  } else {
    DateTime now = rtc.now();

    log( "SD Card initialized" );
  }
}

void log( String text ) {   
  File myFile = SD.open( "status.log", FILE_WRITE );
  if ( myFile ) {

    myFile.println( getTimestamp() + " " + text );
    myFile.close();

    Serial.println( getTimestamp() + " INFO : " + text );
  } else {
    error( "Cannot write to log file" ) ;
  }
}

void error( String text ) {
  File myFile = SD.open( "error.log", FILE_WRITE );
  if ( myFile ) {

    myFile.println( getTimestamp() + " " + text );
    myFile.close();

    Serial.println( getTimestamp() + " ERROR: " + text );
  } else {
    Serial.println( getTimestamp() + " ERROR: Cannot write to error log file" ) ;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// Lower level system functions
//
////////////////////////////////////////////////////////////////////////////////////////////////////

String getTimestamp() {
  DateTime now = rtc.now();
  return formatTime( now.day() ) + "-" + formatTime( now.month() ) + "-" + formatTime( now.year() ) + " " + formatTime( now.hour() ) + ":" + formatTime( now.minute() ) + ":" + formatTime( now.second() );
}

String formatTime( int timeElement ) {
  if ( timeElement > 9 ) {
    return (String)timeElement; 
  } else {
    return "0" + (String)timeElement;
  }
}

